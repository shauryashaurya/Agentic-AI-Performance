# Section 5 — Event Timeline Analysis (Sequences, Loops, Cyclical Failures)

---

## 1. Purpose and scope

* Metrics give aggregate signals but lose **temporal and causal structure**.
* Timeline analysis reconstructs **the ordered sequence of events for each run**.
* This lets you:

  * see exactly what steps occurred and in what order
  * detect loops, retries, and other cyclical patterns
  * understand run context leading up to a failure

---

## 2. Event types relevant to timelines

For this section, we focus on ordered events that describe the **execution flow**:

* `run_start`, `run_ok`, `run_fail`
* `action_start`, `action_result`
* `span_start`, `span_end` (optional for nested tasks)
* `retry` (if emitted separately)
* Any **custom hooks** like `loop_guard_triggered`

Terminal events (`run_ok`, `run_fail`) mark the **end** of the sequence for that run.

---

## 3. Core reconstruction process

1. **Filter** the normalized event table to the relevant `run_id` or set of runs.
2. **Sort** by `ts` then `event_id` for deterministic ordering.
3. **Group** by `run_id`.
4. **Extract** an ordered list of `(kind, name/action, status)` tuples.
5. **Store** as:

   * a list in memory (for per-run inspection)
   * a joined string for sequence pattern matching

Example:

```
run_id=1234 → [
  ('run_start', 'task_A', None),
  ('action_start', 'search', None),
  ('action_result', 'search', 'ok'),
  ('action_start', 'summarize', None),
  ('action_result', 'summarize', 'error'),
  ('run_fail', None, None)
]
```

---

## 4. Loop and cycle detection strategies

1. **Exact repetition**

   * Scan the ordered actions for immediate repeats (e.g., `search → search → search`).
2. **Sliding window comparison**

   * Compare N-grams within the sequence for repeats separated by other actions.
3. **Frequency analysis**

   * Count how many times each action appears in the run; unusually high counts suggest loops.
4. **Duration anomalies**

   * Combine sequence with timestamps to find actions repeating faster or slower than normal.

Example detection rule:

```
if any( sequence[i] == sequence[i+1] for i in range(len(sequence)-1) ):
    flag_as_loop(run_id)
```

---

## 5. Visualizing timelines

On a single laptop, keep visualizations simple:

* **Gantt-like chart**:

  * y-axis = action or span name
  * x-axis = timestamp
  * bars = duration between start/end events
* **Sequence diagrams**:

  * Not rendered dynamically here, but printable ASCII or simple Matplotlib annotations can work
* **Timeline table**:

  * DataFrame with ts, kind, action, status, duration\_s

For loop debugging, a **text-based sequence map** is often faster than a chart.

---

## 6. Testing with synthetic data

* **Force loops**: in synthetic generator, repeat the same action multiple times with identical parameters.
* **Force cyclical patterns**: e.g., `A → B → A → B` with known probability.
* **Force timeouts**: simulate rapid retries under failure.

Then verify:

* Loops are detected by repetition rule.
* Sequences match expected patterns.
* Duration anomalies are flagged.

---

## 7. What to look for in real-world runs

* **Infinite loop candidates**: long runs with repeating identical actions and no progress.
* **Flapping tools**: alternating between two actions repeatedly.
* **Repeated failure pattern**: same action failing after same previous step in many runs.
* **Skipped steps**: missing expected actions due to early termination.

---

## 8. Insights for production LLMOps

* Event timelines let you debug **why** a run failed, not just that it failed.
* Patterns found here can drive:

  * automated loop breakers
  * adaptive retry limits
  * tool health scoring
* Storing a compressed form of the sequence (`sequence_hash`) enables large-scale pattern frequency analysis.

---

## 9. Common pitfalls and mitigations

* **Incomplete sequences**:

  * If ingestion missed events, mark sequence as incomplete; do not make strong conclusions.
* **Unordered timestamps**:

  * Sort consistently by `ts` then `event_id`.
* **Data overload**:

  * Timeline views are per-run; for aggregates, analyze compressed representations.
* **False loops**:

  * Repeated action names with different parameters may not be actual loops — include relevant attrs in loop detection.

